#!/usr/bin/env bash
# -*-mode:sh-*- vim:ft=shell-script
# shellcheck shell=bash

# dotfiles-test
# =============================================================================
# Validates dotfiles installation by running automated checks and providing
# a manual verification checklist for visual/interactive tests.

set -euo pipefail

# Colors and formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
RESET='\033[0m'

# Counters
TESTS_RUN=0
TESTS_PASSED=0
TESTS_FAILED=0
TESTS_SKIPPED=0

# =============================================================================
# Utility Functions
# =============================================================================

pass() {
  ((TESTS_RUN++))
  ((TESTS_PASSED++))
  echo -e "  ${GREEN}✓${RESET} $1"
}

fail() {
  ((TESTS_RUN++))
  ((TESTS_FAILED++))
  echo -e "  ${RED}✗${RESET} $1"
}

skip() {
  ((TESTS_SKIPPED++))
  echo -e "  ${YELLOW}○${RESET} $1 (skipped)"
}

section() {
  echo ""
  echo -e "${BOLD}[$1]${RESET}"
}

header() {
  echo ""
  echo "================================================================================"
  echo -e "${BOLD}                        DOTFILES TEST SUITE${RESET}"
  echo "================================================================================"
}

# Check if output contains ANSI escape sequences
has_ansi_codes() {
  local output="$1"
  [[ "$output" == *$'\e['* ]] || [[ "$output" == *$'\033['* ]]
}

# Run a command in interactive zsh and return its exit code
zsh_check() {
  zsh -i -c "$1" 2>/dev/null
}

# test if an environment variable exists in zsh
test_env_exists() {
  if zsh_check "[[ -n "\$$1" ]]"; then
    local mode
    mode=$(zsh -i -c "echo \$$1" 2>/dev/null)
    pass "$1=$mode"
  else
    fail "$1 not set"
  fi
}

# =============================================================================
# Automated Tests
# =============================================================================

test_commands_installed() {
  section "Command Installation"

  local commands=("bat" "chezmoi" "eza" "fd" "fzf" "git" "git-ignore" "go" "nvim" "oh-my-posh" "rg" "shellcheck" "shfmt" "tree" "zoxide" "zsh")

  for cmd in "${commands[@]}"; do
    if command -v "$cmd" &>/dev/null; then
      pass "$cmd is installed"
    else
      fail "$cmd not found"
    fi
  done
}

test_environment_variables() {
  section "Environment Variables"

  # These need to be checked in zsh context
  test_env_exists "XDG_BIN_HOME"
  test_env_exists "XDG_CACHE_HOME"
  test_env_exists "XDG_CONFIG_HOME"
  test_env_exists "XDG_DATA_HOME"
  test_env_exists "XDG_STATE_HOME"
  test_env_exists "ZDOTDIR"
  test_env_exists "LS_COLORS"
  test_env_exists "LSCOLORS"
  test_env_exists "FZF_DEFAULT_OPTS"

  if zsh_check '[[ "$CLICOLOR" == "1" ]]'; then
    pass "CLICOLOR=1"
  else
    fail "CLICOLOR not set to 1"
  fi
}

test_completion_system() {
  section "Completion System"

  if zsh_check 'type compdef &>/dev/null'; then
    pass "compdef function exists (compinit loaded)"
  else
    fail "compdef not found (compinit not loaded)"
  fi

  if zsh_check 'zmodload -L 2>/dev/null | grep -q complist'; then
    pass "zsh/complist module loaded"
  else
    fail "zsh/complist module not loaded"
  fi

  if zsh_check 'zstyle -L ":fzf-tab:*" &>/dev/null'; then
    pass "fzf-tab zstyles configured"
  else
    fail "fzf-tab zstyles not found"
  fi
}

test_plugins_loaded() {
  section "Plugins"

  if zsh_check 'type _zsh_highlight &>/dev/null'; then
    pass "fast-syntax-highlighting loaded"
  else
    fail "fast-syntax-highlighting not loaded"
  fi

  if zsh_check '[[ -n "$ZSH_AUTOSUGGEST_HIGHLIGHT_STYLE" ]] || type autosuggest-accept &>/dev/null'; then
    pass "zsh-autosuggestions loaded"
  else
    fail "zsh-autosuggestions not loaded"
  fi

  if zsh_check 'type fzf-tab-complete &>/dev/null'; then
    pass "fzf-tab loaded"
  else
    fail "fzf-tab not loaded"
  fi
}

test_prompt_configured() {
  section "Prompt Configuration"

  if zsh_check 'type _omp_precmd &>/dev/null'; then
    pass "oh-my-posh precmd hook installed"
  else
    fail "oh-my-posh precmd hook not found"
  fi
}

test_color_output() {
  section "Color Output Detection"

  if command -v eza &>/dev/null; then
    local eza_output
    eza_output=$(eza --color=always / 2>/dev/null | head -1)
    if has_ansi_codes "$eza_output"; then
      pass "eza produces ANSI color codes"
    else
      fail "eza not producing color output"
    fi
  else
    skip "eza not installed"
  fi

  if command -v bat &>/dev/null; then
    local bat_output
    # Create a temp file to test bat
    local tmpfile
    tmpfile=$(mktemp)
    echo 'echo "hello"' >"$tmpfile"
    bat_output=$(bat --color=always --style=plain "$tmpfile" 2>/dev/null)
    rm -f "$tmpfile"
    if has_ansi_codes "$bat_output"; then
      pass "bat produces ANSI color codes"
    else
      fail "bat not producing color output"
    fi
  else
    skip "bat not installed"
  fi

  if command -v oh-my-posh &>/dev/null; then
    local omp_output
    omp_output=$(oh-my-posh print primary 2>/dev/null)
    if has_ansi_codes "$omp_output"; then
      pass "oh-my-posh produces ANSI color codes"
    else
      fail "oh-my-posh not producing color output"
    fi
  else
    skip "oh-my-posh not installed"
  fi
}

test_config_files() {
  section "Configuration Files"

  local config_home="${XDG_CONFIG_HOME:-$HOME/.config}"

  if [[ -f "$config_home/bat/config" ]]; then
    pass "bat config exists"
  else
    fail "bat config not found"
  fi

  if [[ -f "$config_home/fd/fd.ignore" ]]; then
    pass "fd ignore exists"
  else
    fail "fd ignore not found"
  fi

  if [[ -f "$config_home/git/config" ]]; then
    pass "git config exists"
  else
    fail "git config not found"
  fi

  if [[ -f "$config_home/git/ignore" ]]; then
    pass "git ignore exists"
  else
    fail "git ignore not found"
  fi

  if [[ -f "$config_home/zsh/.zshrc" ]]; then
    pass "zshrc exists"
  else
    fail "zshrc not found"
  fi

  if [[ -d "$config_home/zsh/zshrc.d" ]]; then
    local count
    count=$(find "$config_home/zsh/zshrc.d" -name "*.zsh" 2>/dev/null | wc -l | tr -d ' ')
    pass "zshrc.d exists with $count modules"
  else
    fail "zshrc.d directory not found"
  fi
}

test_fzf_keybindings() {
  section "FZF Keybindings"

  if zsh_check 'bindkey | grep -q fzf-file-widget'; then
    pass "CTRL-T (fzf-file-widget) bound"
  else
    fail "CTRL-T not bound to fzf-file-widget"
  fi

  if zsh_check 'bindkey | grep -q fzf-cd-widget'; then
    pass "ALT-C (fzf-cd-widget) bound"
  else
    fail "ALT-C not bound to fzf-cd-widget"
  fi

  if zsh_check 'bindkey | grep -q fzf-history-widget'; then
    pass "CTRL-R (fzf-history-widget) bound"
  else
    fail "CTRL-R not bound to fzf-history-widget"
  fi
}

test_aliases_defined() {
  section "Aliases"

  if zsh_check 'alias ls 2>/dev/null | grep -q eza'; then
    pass "ls aliased to eza"
  elif zsh_check 'alias ls &>/dev/null'; then
    pass "ls alias defined"
  else
    fail "ls alias not defined"
  fi

  if zsh_check 'alias ll &>/dev/null'; then
    pass "ll alias defined"
  else
    fail "ll alias not defined"
  fi

  if zsh_check 'alias la &>/dev/null'; then
    pass "la alias defined"
  else
    fail "la alias not defined"
  fi
}

# =============================================================================
# Manual Verification Checklist
# =============================================================================

manual_test() {
  local description="$1"
  local instruction="$2"

  echo ""
  echo -e "${BOLD}TEST:${RESET} $description"
  echo -e "${BLUE}→${RESET} $instruction"
  echo ""

  local response
  while true; do
    read -r -p "Result? [p]ass / [f]ail / [s]kip: " response
    case "$response" in
    p | P | pass)
      ((MANUAL_PASSED++))
      echo -e "  ${GREEN}✓${RESET} Passed"
      break
      ;;
    f | F | fail)
      ((MANUAL_FAILED++))
      echo -e "  ${RED}✗${RESET} Failed"
      break
      ;;
    s | S | skip)
      ((MANUAL_SKIPPED++))
      echo -e "  ${YELLOW}○${RESET} Skipped"
      break
      ;;
    *)
      echo "Please enter p, f, or s"
      ;;
    esac
  done
}

run_manual_tests() {
  MANUAL_PASSED=0
  MANUAL_FAILED=0
  MANUAL_SKIPPED=0

  echo ""
  echo "================================================================================"
  echo -e "${BOLD}                    INTERACTIVE MANUAL TESTS${RESET}"
  echo "================================================================================"
  echo ""
  echo "For each test, try the action in your terminal and report the result."
  echo "Press Enter after each response to continue."

  # Completions
  echo ""
  echo -e "${BOLD}── COMPLETIONS ──${RESET}"

  manual_test "fzf-tab completion" \
    "Type 'git c<TAB>' - fzf menu should appear with clone, commit, checkout, etc."

  manual_test "Directory completion" \
    "Type 'cd ~/<TAB><TAB>' - fzf menu should show directories (double-TAB triggers fzf)"

  manual_test "Flag completion" \
    "Type 'ls -<TAB>' - completion menu should show ls/eza flags"

  # FZF Keybindings
  echo ""
  echo -e "${BOLD}── FZF KEYBINDINGS ──${RESET}"

  manual_test "CTRL-T file picker" \
    "Press CTRL-T - file picker with preview (? toggles, CTRL-F/B scrolls preview)"

  manual_test "CTRL-R history search" \
    "Press CTRL-R - history search should appear with command preview"

  # Colors
  echo ""
  echo -e "${BOLD}── COLORS ──${RESET}"

  manual_test "eza/ls colors" \
    "Run 'ls' or 'eza' - directories blue, executables green/red"

  manual_test "bat syntax highlighting" \
    "Run 'bat ~/.zshrc' - syntax highlighting should appear"

  manual_test "Prompt colors" \
    "Check prompt - path blue, git branch green, prompt char cyan"

  # Prompt Behavior
  echo ""
  echo -e "${BOLD}── PROMPT BEHAVIOR ──${RESET}"

  manual_test "Git status in prompt" \
    "cd into a git repo - branch and status indicators should appear"

  manual_test "Error status indicator" \
    "Run 'false' (exits with error) - prompt char should turn magenta"

  manual_test "Execution time" \
    "Run 'sleep 1' - execution time should appear on right side"

  # Zoxide
  echo ""
  echo -e "${BOLD}── ZOXIDE ──${RESET}"

  manual_test "Zoxide jump" \
    "Type 'cd <partial-path>' (e.g., 'cd dot') - should jump to matching directory"

  manual_test "Zoxide interactive" \
    "Type 'cdi' - interactive directory selection should appear"

  # Autosuggestions
  echo ""
  echo -e "${BOLD}── AUTOSUGGESTIONS ──${RESET}"

  manual_test "Command suggestions" \
    "Start typing a previous command - grey suggestion should appear"

  manual_test "Accept suggestion" \
    "Press right arrow or END to accept the grey suggestion"

  # Syntax Highlighting
  echo ""
  echo -e "${BOLD}── SYNTAX HIGHLIGHTING ──${RESET}"

  manual_test "String highlighting" \
    "Type 'echo \"hello\"' (don't run) - string should be highlighted"

  manual_test "Invalid command" \
    "Type 'notarealcmd' (don't run) - should appear red"

  manual_test "Valid command" \
    "Type 'ls' (don't run) - should appear green"

  # Summary
  echo ""
  echo "================================================================================"
  local total=$((MANUAL_PASSED + MANUAL_FAILED + MANUAL_SKIPPED))
  if [[ $MANUAL_FAILED -eq 0 ]]; then
    echo -e "${GREEN}${BOLD}MANUAL RESULTS: $MANUAL_PASSED/$total passed${RESET}"
  else
    echo -e "${RED}${BOLD}MANUAL RESULTS: $MANUAL_PASSED/$total passed ($MANUAL_FAILED failed)${RESET}"
  fi
  if [[ $MANUAL_SKIPPED -gt 0 ]]; then
    echo -e "${YELLOW}($MANUAL_SKIPPED skipped)${RESET}"
  fi
  echo "================================================================================"
}

# =============================================================================
# Main
# =============================================================================

print_summary() {
  echo ""
  echo "================================================================================"
  if [[ $TESTS_FAILED -eq 0 ]]; then
    echo -e "${GREEN}${BOLD}RESULTS: $TESTS_PASSED/$TESTS_RUN passed${RESET}"
  else
    echo -e "${RED}${BOLD}RESULTS: $TESTS_PASSED/$TESTS_RUN passed ($TESTS_FAILED failed)${RESET}"
  fi
  if [[ $TESTS_SKIPPED -gt 0 ]]; then
    echo -e "${YELLOW}($TESTS_SKIPPED tests skipped)${RESET}"
  fi
  echo "================================================================================"
}

show_help() {
  echo "Usage: dotfiles-test [OPTIONS]"
  echo ""
  echo "Validate dotfiles installation."
  echo ""
  echo "Options:"
  echo "  --auto-only    Run automated tests only (skip manual checklist)"
  echo "  --help         Show this help message"
  echo ""
}

main() {
  local auto_only=false

  while [[ $# -gt 0 ]]; do
    case $1 in
    --auto-only)
      auto_only=true
      shift
      ;;
    --help | -h)
      show_help
      exit 0
      ;;
    *)
      echo "Unknown option: $1"
      show_help
      exit 1
      ;;
    esac
  done

  header

  test_commands_installed
  test_environment_variables
  test_completion_system
  test_plugins_loaded
  test_prompt_configured
  test_color_output
  test_config_files
  test_fzf_keybindings
  test_aliases_defined

  print_summary

  if [[ "$auto_only" == false ]]; then
    run_manual_tests
  fi

  # Exit with appropriate code
  if [[ $TESTS_FAILED -gt 0 ]]; then
    exit 1
  elif [[ $TESTS_SKIPPED -gt 0 ]]; then
    exit 2
  else
    exit 0
  fi
}

main "$@"
